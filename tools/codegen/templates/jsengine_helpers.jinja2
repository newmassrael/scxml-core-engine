    // Helper: Ensure session ID is initialized
    void ensureSessionId() const {
        if (!sessionId_.has_value()) {
            sessionId_ = "session_" + std::to_string(reinterpret_cast<uintptr_t>(this));
        }
    }

{% if model.needs_jsengine %}
    // Helper: Ensure JSEngine is initialized (lazy initialization)
    void ensureJSEngine() const {
        if (jsEngineInitialized_) return;
        ensureSessionId();
        if (!sessionId_.has_value()) return;
        auto& jsEngine = ::RSM::JSEngine::instance();
        jsEngine.createSession(sessionId_.value());

        // W3C SCXML 5.10: Setup system variables (_sessionid, _name, _ioprocessors) using SystemVariableHelper
        // ARCHITECTURE.md Zero Duplication: SystemVariableHelper provides Single Source of Truth
        std::vector<std::string> ioProcessors = {"scxml"};  // W3C SCXML I/O Processors
        auto setupResult = ::RSM::SystemVariableHelper::setupSystemVariables(sessionId_.value(), "{{ model.name }}", ioProcessors).get();
        if (!setupResult.isSuccess()) {
            LOG_ERROR("AOT ensureJSEngine: Failed to setup system variables: {}", setupResult.getErrorMessage());
        }

{% for var in model.variables %}
{% if var.expr %}
        auto initExpr_{{ var.id }} = jsEngine.evaluateExpression(sessionId_.value(), "{{ var.expr | escape_cpp }}").get();
        if (!::RSM::JSEngine::isSuccess(initExpr_{{ var.id }})) {
            LOG_ERROR("Failed to evaluate expression for variable: {{ var.id }}");
        } else {
            jsEngine.setVariable(sessionId_.value(), "{{ var.id }}", initExpr_{{ var.id }}.getInternalValue());
        }
{% elif var.content %}
        auto initExpr_{{ var.id }} = jsEngine.evaluateExpression(sessionId_.value(), R"({{ var.content | escape_cpp }})").get();
        if (!::RSM::JSEngine::isSuccess(initExpr_{{ var.id }})) {
            LOG_ERROR("Failed to evaluate expression for variable: {{ var.id }}");
        } else {
            jsEngine.setVariable(sessionId_.value(), "{{ var.id }}", initExpr_{{ var.id }}.getInternalValue());
        }
{% elif var.type == 'runtime' %}
        auto initExpr_{{ var.id }} = jsEngine.evaluateExpression(sessionId_.value(), "undefined").get();
        if (!::RSM::JSEngine::isSuccess(initExpr_{{ var.id }})) {
            LOG_ERROR("Failed to evaluate expression for variable: {{ var.id }}");
        } else {
            jsEngine.setVariable(sessionId_.value(), "{{ var.id }}", initExpr_{{ var.id }}.getInternalValue());
        }
{% endif %}
{% endfor %}

{% if model.has_parallel_states or model.uses_in_predicate %}
        // W3C SCXML 5.9.2: Register state query callback for In() predicate support
        // ARCHITECTURE.md All-or-Nothing Strategy: Static AOT engines cannot hold StateMachine*
        // pointers (no base class). Callback mechanism provides In() capability while maintaining
        // compile-time static structure. isStateActive() uses InPredicateHelper for shared logic.
        jsEngine.setStateQueryCallback(
            [this](const std::string& stateId) { return this->isStateActive(stateId); },
            sessionId_.value()
        );
        LOG_DEBUG("AOT ensureJSEngine: Registered state query callback for In() predicate");
{% endif %}

        jsEngineInitialized_ = true;
    }

    // ARCHITECTURE.MD: Zero Duplication - Use DataModelInitHelper (shared with Interpreter)
    // W3C SCXML 5.2/5.3: Initialize datamodel and raise error.execution if failed
    // Called during StaticExecutionEngine::initialize() to ensure proper error event timing
    template<typename Engine>
    void initializeDataModel(Engine& engine) {
        if (jsEngineInitialized_) return;
        ensureSessionId();
        if (!sessionId_.has_value()) return;
        auto& jsEngine = ::RSM::JSEngine::instance();
        jsEngine.createSession(sessionId_.value());

        // W3C SCXML 5.10: Setup system variables (_sessionid, _name, _ioprocessors) using SystemVariableHelper
        // ARCHITECTURE.md Zero Duplication: SystemVariableHelper provides Single Source of Truth
        std::vector<std::string> ioProcessors = {"scxml"};  // W3C SCXML I/O Processors
        auto setupResult = ::RSM::SystemVariableHelper::setupSystemVariables(sessionId_.value(), "{{ model.name }}", ioProcessors).get();
        if (!setupResult.isSuccess()) {
            LOG_ERROR("AOT initializeDataModel: Failed to setup system variables: {}", setupResult.getErrorMessage());
        }
{% if not model.variables %}
        (void)engine;  // No variables to initialize
{% endif %}

{% for var in model.variables %}
{% if var.src %}
        // W3C SCXML 5.2.2: Load datamodel variable from external file
        // basePath is relative to test execution directory (e.g., "w3c_static_generated" for W3C tests)
        ::RSM::DataModelInitHelper::initializeVariableFromSrc(
            jsEngine, sessionId_.value(), "{{ var.id }}", "{{ var.src }}", "{{ base_path }}",
            [&engine](const ::std::string& msg) {
                engine.raise(typename Engine::EventWithMetadata(Event::Error_execution, msg));
            });
{% elif var.expr %}
{# ARCHITECTURE.md: Zero Duplication - Function detection matches DataModelInitHelper::isFunctionExpression() #}
{# W3C SCXML B.2: Template-time detection (Python) for code generation optimization #}
{% set is_function_expr = var.expr.strip().startswith('function') %}
{% if is_function_expr %}
        // W3C SCXML B.2: For function expressions, use direct JavaScript assignment to preserve function type
        // Test 453: ECMAScript function literals must be stored as functions, not converted to C++
        // ARCHITECTURE.md Zero Duplication: Matches Interpreter behavior (StateMachine.cpp:1615-1635)
        {
            auto scriptResult = jsEngine.executeScript(sessionId_.value(), "{{ var.id }} = {{ var.expr | escape_cpp }}").get();
            if (!::RSM::JSEngine::isSuccess(scriptResult)) {
                std::string errorMsg = "Failed to assign function expression for '{{ var.id }}'";
                LOG_ERROR("AOT initializeDataModel: {}", errorMsg);
                engine.raise(typename Engine::EventWithMetadata(Event::Error_execution, errorMsg));
            }
            LOG_DEBUG("AOT initializeDataModel: Initialized function variable '{{ var.id }}'");
        }
{% else %}
        // W3C SCXML 5.2/5.3: Use shared Helper for datamodel initialization
        ::RSM::DataModelInitHelper::initializeVariable(
            jsEngine, sessionId_.value(), "{{ var.id }}", "{{ var.expr | escape_cpp }}",
            [&engine](const ::std::string& msg) {
                engine.raise(typename Engine::EventWithMetadata(Event::Error_execution, msg));
            });
{% endif %}
{% elif var.content %}
        // W3C SCXML B.2: Initialize with inline XML content (DOM creation)
        ::RSM::DataModelInitHelper::initializeVariable(
            jsEngine, sessionId_.value(), "{{ var.id }}", R"({{ var.content }})",
            [&engine](const ::std::string& msg) {
                engine.raise(typename Engine::EventWithMetadata(Event::Error_execution, msg));
            });
{% elif var.type == 'runtime' %}
        // W3C SCXML 5.2: Runtime datamodel variable (late binding)
        ::RSM::DataModelInitHelper::initializeVariable(
            jsEngine, sessionId_.value(), "{{ var.id }}", "",
            [&engine](const ::std::string& msg) {
                engine.raise(typename Engine::EventWithMetadata(Event::Error_execution, msg));
            });
{% endif %}
{% endfor %}

{% if model.global_scripts %}
        // W3C SCXML 5.8: Execute global (top-level) scripts at document load time
        // ARCHITECTURE.md Zero Duplication: Matches Interpreter behavior (StateMachine.cpp execution order)
        // Execution order: datamodel init → global scripts → state machine start
{% for script in model.global_scripts %}
        {
            auto scriptResult = jsEngine.executeScript(sessionId_.value(), "{{ script.content | escape_cpp }}").get();
            if (!::RSM::JSEngine::isSuccess(scriptResult)) {
                std::string errorMsg = "Global script execution failed";
                LOG_ERROR("W3C SCXML 5.8: {}", errorMsg);
                engine.raise(typename Engine::EventWithMetadata(Event::Error_execution, errorMsg));
            }
        }
{% endfor %}
{% endif %}

{% if model.has_parallel_states or model.uses_in_predicate %}
        // W3C SCXML 5.9.2: Register state query callback for In() predicate support
        // ARCHITECTURE.md All-or-Nothing Strategy: Static AOT engines cannot hold StateMachine*
        // pointers (no base class). Callback mechanism provides In() capability while maintaining
        // compile-time static structure. isStateActive() uses InPredicateHelper for shared logic.
        jsEngine.setStateQueryCallback(
            [this](const std::string& stateId) { return this->isStateActive(stateId); },
            sessionId_.value()
        );
        LOG_DEBUG("AOT initializeDataModel: Registered state query callback for In() predicate");
{% endif %}

        jsEngineInitialized_ = true;
    }
{% endif %}
