/**
 * Real AOT Engine Code Generator Template
 * Matches actual codegen.py output
 */

function generateAOTCode(scxmlDoc) {
    const stateMachine = scxmlDoc.getElementsByTagName('scxml')[0];
    const states = Array.from(scxmlDoc.getElementsByTagName('state'));
    const smName = stateMachine.getAttribute('name') || 'StateMachine';
    const initialState = stateMachine.getAttribute('initial');

    if (!initialState) {
        throw new Error('SCXML must have an initial state attribute');
    }

    // Collect events
    const eventsSet = new Set();
    states.forEach(state => {
        const transitions = state.getElementsByTagName('transition');
        Array.from(transitions).forEach(trans => {
            const event = trans.getAttribute('event');
            if (event) eventsSet.add(event);
        });
    });
    const events = Array.from(eventsSet).sort();

    // Generate state names (capitalize first letter for enum)
    const stateNames = states.map(s => {
        const id = s.getAttribute('id');
        return id.charAt(0).toUpperCase() + id.slice(1);
    });

    // Generate event names (uppercase with underscores)
    const eventNames = events.map(e =>
        e.split(/[_-]/).map(part => part.charAt(0).toUpperCase() + part.slice(1)).join('_')
    );

    // Build transitions map
    const transitions = {};
    states.forEach(state => {
        const stateId = state.getAttribute('id');
        const stateName = stateId.charAt(0).toUpperCase() + stateId.slice(1);
        const transElements = state.getElementsByTagName('transition');

        Array.from(transElements).forEach(trans => {
            const event = trans.getAttribute('event');
            const target = trans.getAttribute('target');
            if (event && target) {
                if (!transitions[stateName]) transitions[stateName] = [];
                transitions[stateName].push({
                    event: event,
                    eventName: event.split(/[_-]/).map(p => p.charAt(0).toUpperCase() + p.slice(1)).join('_'),
                    target: target.charAt(0).toUpperCase() + target.slice(1)
                });
            }
        });
    });

    // Generate code
    let code = `// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: 2025 [Author of input SCXML file]
//
// Generated by SCE Code Generator (Web Version)
//
// This generated code is MIT licensed and may be freely used in any project.
// Runtime engine dependency: LGPL-2.1-or-later OR LicenseRef-SCE-Commercial
// Full license: https://github.com/newmassrael/scxml-core-engine/blob/main/LICENSE
#pragma once
#include <chrono>
#include <cstdint>
#include <memory>
#include <stdexcept>
#include <string>
#include <unordered_map>
#include "static/StaticExecutionEngine.h"
#include "common/TransitionHelper.h"
#include "common/HistoryHelper.h"
#include "common/StateEntryHelper.h"
#include "common/EntryExitHelper.h"
#include "common/EventMatchingHelper.h"
#include "common/EventDataHelper.h"
#include "common/InPredicateHelper.h"

namespace SCE::Generated::@@smName@@ {

class @@smName@@;

enum class State : uint8_t {
    @@stateEnums@@
};

enum class Event : uint8_t {
    NONE,  // W3C SCXML 6.2: Default event for scheduler polling (no semantic meaning)
    @@eventEnums@@
};

/**
 * @brief Transition information for microstep execution
 *
 * W3C SCXML Appendix D: Optimal enabled transition set execution requires
 * collecting all enabled transitions before executing any (atomic microstep).
 */
struct TransitionInfo {
    State source;              // W3C SCXML 3.13: Source state of transition
    State target;              // Target state of transition
    int transitionIndex;       // Index of transition in source state (for executeTransitionActions)
    bool hasActions;           // Whether transition has executable content
    bool isInternal;           // W3C SCXML 3.13: Whether transition is type="internal"
    bool isTargetless;         // W3C SCXML 5.9.2: Whether transition has no target (consumes event only)

    TransitionInfo(State src, State tgt, int idx, bool actions, bool internal = false, bool targetless = false)
        : source(src), target(tgt), transitionIndex(idx), hasActions(actions), isInternal(internal), isTargetless(targetless) {}
};

// State policy for @@smName@@
struct @@smName@@Policy {
    using State = ::SCE::Generated::@@smName@@::State;
    using Event = ::SCE::Generated::@@smName@@::Event;

    // W3C SCXML Appendix D: Flag indicating parallel state support
    static constexpr bool HAS_PARALLEL_STATES = false;

    // W3C SCXML 5.9: Flag indicating JSEngine requirement (ECMAScript expressions)
    static constexpr bool NEEDS_JSENGINE = false;

    // W3C SCXML 3.13: Track last transition for deferred action execution
    mutable State lastTransitionSourceState_{};
    mutable bool lastTransitionIsInternal_ = false;
    mutable bool lastTransitionIsTargetless_ = false;

    // Default constructor (lazy initialization, no immediate resource allocation)
    @@smName@@Policy() = default;

    static State initialState() {
        return State::@@initialStateEnum@@;
    }

    static bool isFinalState(State state) {
        (void)state;
        return false;
    }

    // W3C SCXML 3.3: Parent state mapping (for HierarchicalStateHelper)
    static std::optional<State> getParent(State state) {
        (void)state;
        return std::nullopt;  // Root state
    }

    // W3C SCXML 3.3: Check if state is compound (has initial child)
    static bool isCompoundState(State state) {
        (void)state;
        return false;
    }

    // W3C SCXML 3.6: Get initial children of compound state
    static std::vector<State> getInitialChildren(State state) {
        (void)state;
        return {};
    }

    // W3C SCXML 3.3: Get single initial child (backward compatibility)
    static State getInitialChild(State state) {
        auto children = getInitialChildren(state);
        return children.empty() ? state : children[0];
    }

    // W3C SCXML 3.11: Get initial or history-restored child
    State getInitialOrHistoryChild(State state) const {
        (void)state;
        return state;
    }

    template<typename Engine>
    static void executeEntryActions(State state, Engine& engine) {
        (void)engine;
        (void)state;
    }

    template<typename Engine>
    static void executeExitActions(State state, Engine& engine, const std::vector<State>& activeStatesBeforeTransition) {
        (void)engine;
        (void)state;
        (void)activeStatesBeforeTransition;
    }

    template<typename Engine>
    bool processTransition(State& currentState, Event event, Engine& engine) {
        (void)engine;
        bool transitionTaken = false;

        // W3C SCXML 3.12: Hierarchical event processing
        State checkState = currentState;
        while (true) {
            bool foundTransition = tryTransitionInState(checkState, event, currentState, transitionTaken, engine);
            if (foundTransition) break;

            // W3C SCXML 3.13: Eventless transitions do NOT bubble to parent states
            if (event == Event()) break;

            auto parent = @@smName@@Policy::getParent(checkState);
            if (!parent.has_value()) break;
            checkState = parent.value();
        }

        return transitionTaken;
    }

private:
    template<typename Engine>
    bool tryTransitionInState(State checkState, Event event, State& currentState,
                              bool& transitionTaken, Engine& engine,
                              ::std::vector<TransitionInfo>* collectMode = nullptr) {
        (void)engine;
        (void)collectMode;

        switch (checkState) {
@@transitionCases@@
        default:
            return false;
        }
    }

public:
    template<typename Engine>
    void executeTransitionActions(Engine& engine) {
        (void)engine;
    }

    // Helper: Convert Event enum to string for _event.name (W3C SCXML 5.10)
    static std::string getEventName(Event event) {
        switch (event) {
            case Event::NONE: return "";
@@eventNameCases@@
            default: return "";
        }
    }

    // Helper: Convert event name string to Event enum
    static std::optional<Event> getEventFromName(const std::string& eventName) {
        if (eventName.empty()) return std::nullopt;
@@eventFromNameCases@@
        return std::nullopt;
    }

private:

public:
    void setCurrentEventInJSEngine(const std::string& eventName, const std::string& eventData = "",
                                const std::string& eventType = "", const std::string& sendId = "",
                                const std::string& origin = "", const std::string& originType = "",
                                const std::string& invokeId = "") {
        (void)eventName; (void)eventData; (void)eventType; (void)sendId;
        (void)origin; (void)originType; (void)invokeId;
    }

    void ensureJSEngineSessionDestroyed() const {
    }
};

// User-facing state machine class
class @@smName@@ : public ::SCE::Static::StaticExecutionEngine<@@smName@@Policy> {
public:
    using PolicyType = @@smName@@Policy;
    @@smName@@() = default;
};

} // namespace SCE::Generated::@@smName@@
`;

    // Replace template variables
    code = code.replace(/@@smName@@/g, smName);
    code = code.replace(/@@stateEnums@@/g, stateNames.join(',\n    '));
    code = code.replace(/@@eventEnums@@/g, eventNames.join(',\n    '));
    code = code.replace(/@@initialStateEnum@@/g, initialState.charAt(0).toUpperCase() + initialState.slice(1));

    // Generate transition cases
    let transitionCases = '';
    for (const [stateName, trans] of Object.entries(transitions)) {
        transitionCases += `        case State::${stateName}:\n`;
        trans.forEach(t => {
            transitionCases += `            // W3C SCXML 5.9.3: Event descriptor matching\n`;
            transitionCases += `            if (event != Event::NONE && ::SCE::EventMatchingHelper::matchesEventDescriptor(\n`;
            transitionCases += `                ${smName}Policy::getEventName(event), "${t.event}")) {\n`;
            transitionCases += `                lastTransitionSourceState_ = checkState;\n`;
            transitionCases += `                lastTransitionIsInternal_ = false;\n`;
            transitionCases += `                lastTransitionIsTargetless_ = false;\n`;
            transitionCases += `                if (collectMode != nullptr) {\n`;
            transitionCases += `                    collectMode->push_back(TransitionInfo(checkState, State::${t.target}, 0, false, false, false));\n`;
            transitionCases += `                } else {\n`;
            transitionCases += `                    currentState = State::${t.target};\n`;
            transitionCases += `                    transitionTaken = true;\n`;
            transitionCases += `                }\n`;
            transitionCases += `                return true;\n`;
            transitionCases += `            }\n`;
        });
        transitionCases += `            return false;\n`;
    }
    code = code.replace(/@@transitionCases@@/g, transitionCases);

    // Generate event name cases
    let eventNameCases = '';
    events.forEach((event, idx) => {
        eventNameCases += `            case Event::${eventNames[idx]}: return "${event}";\n`;
    });
    code = code.replace(/@@eventNameCases@@/g, eventNameCases);

    // Generate event from name cases
    let eventFromNameCases = '';
    events.forEach((event, idx) => {
        eventFromNameCases += `        if (eventName == "${event}") return Event::${eventNames[idx]};\n`;
    });
    code = code.replace(/@@eventFromNameCases@@/g, eventFromNameCases);

    return code;
}

// Export for use in index.html
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { generateAOTCode };
}
