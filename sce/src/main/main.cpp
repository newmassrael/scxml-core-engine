#include <cstring>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <string>

// Include parsing components
#include "../../include/Logger.h"
#include "../../include/common/TypeRegistry.h"
#include "../../include/events/EventRaiserService.h"
#include "../../include/factory/NodeFactory.h"
#include "../../include/model/SCXMLModel.h"
#include "../../include/parsing/SCXMLParser.h"

namespace fs = std::filesystem;

void printUsage(const char *programName) {
    SCE::LOG_INFO("SCXML Code Generator\n");
    SCE::LOG_INFO("Usage: {} [options] <input.scxml>\n", programName);
    SCE::LOG_INFO("Options:");
    SCE::LOG_INFO("  -o, --output <file>    Output file path (default: generated.cpp)");
    SCE::LOG_INFO("  -h, --help            Show this help message");
    SCE::LOG_INFO("  -v, --verbose         Enable verbose logging\n");
    SCE::LOG_INFO("Examples:");
    SCE::LOG_INFO("  {} state_machine.scxml", programName);
    SCE::LOG_INFO("  {} -o my_sm.cpp input.scxml", programName);
    SCE::LOG_INFO("  {} --verbose --output=generated.hpp input.scxml", programName);
}

void printVersion() {
    SCE::LOG_INFO("scxml-codegen version 1.0.0");
    SCE::LOG_INFO("SCXML-to-C++ Code Generator");
}

int main(int argc, char *argv[]) {
    std::string inputFile;
    std::string outputFile = "generated.cpp";
    bool verbose = false;

    // Parse command line arguments
    for (int i = 1; i < argc; ++i) {
        std::string arg(argv[i]);

        if (arg == "-h" || arg == "--help") {
            printUsage(argv[0]);
            return 0;
        } else if (arg == "-v" || arg == "--verbose") {
            verbose = true;
        } else if (arg == "--version") {
            printVersion();
            return 0;
        } else if (arg == "-o" || arg == "--output") {
            if (i + 1 < argc) {
                outputFile = argv[++i];
            } else {
                SCE::LOG_ERROR("Error: --output requires a file path");
                return 1;
            }
        } else if (arg.starts_with("--output=")) {
            outputFile = arg.substr(9);
        } else if (arg.starts_with("-")) {
            SCE::LOG_ERROR("Error: Unknown option {}", arg);
            printUsage(argv[0]);
            return 1;
        } else {
            if (inputFile.empty()) {
                inputFile = arg;
            } else {
                SCE::LOG_ERROR("Error: Multiple input files specified");
                return 1;
            }
        }
    }

    // Validate arguments
    if (inputFile.empty()) {
        SCE::LOG_ERROR("Error: No input file specified");
        printUsage(argv[0]);
        return 1;
    }

    if (!fs::exists(inputFile)) {
        SCE::LOG_ERROR("Error: Input file '{}' does not exist", inputFile);
        return 1;
    }

    // Set logging level
    if (verbose) {
        // Logger has no static level setting, so currently ignored
        LOG_INFO("Verbose mode enabled");
    }

    try {
        LOG_INFO("Starting SCXML code generation...");
        LOG_INFO("Input file: " + inputFile);
        LOG_INFO("Output file: " + outputFile);

        // Parse SCXML file
        auto nodeFactory = std::make_shared<SCE::NodeFactory>();
        SCE::SCXMLParser parser(nodeFactory);
        auto model = parser.parseFile(inputFile);

        if (!model) {
            SCE::LOG_ERROR("Error: Failed to parse SCXML file");
            return 1;
        }

        LOG_INFO("SCXML parsing completed successfully");

        // Generate C++ code
        std::ofstream outFile(outputFile);
        if (!outFile.is_open()) {
            SCE::LOG_ERROR("Error: Cannot create output file '{}'", outputFile);
            return 1;
        }

        // Generate header
        outFile << "// Generated by scxml-codegen from " << inputFile << "\n";
        outFile << "// Do not edit this file manually\n\n";
        outFile << "#include \"scxml/SCXMLEngine.h\"\n";
        outFile << "#include \"scxml/SCXMLTypes.h\"\n\n";

        // Generate state machine class
        std::string className = fs::path(inputFile).stem().string() + "StateMachine";
        outFile << "class " << className << " {\n";
        outFile << "public:\n";
        outFile << "    " << className << "() {\n";
        outFile << "        engine = SCXML::createSCXMLEngine();\n";
        outFile << "        engine->initialize();\n";
        outFile << "        engine->createSession(\"main\");\n";
        outFile << "    }\n\n";
        outFile << "    ~" << className << "() {\n";
        outFile << "        if (engine) {\n";
        outFile << "            engine->destroySession(\"main\");\n";
        outFile << "            engine->shutdown();\n";
        outFile << "        }\n";
        outFile << "    }\n\n";
        outFile << "    void start() {\n";
        outFile << "        // TODO: Generate state machine logic based on SCXML\n";
        outFile << "        // This is a placeholder implementation\n";
        outFile << "    }\n\n";
        outFile << "    void processEvent(const std::string& eventName) {\n";
        outFile << "        auto event = std::make_shared<SCXML::Event>(eventName);\n";
        outFile << "        engine->setCurrentEvent(\"main\", event);\n";
        outFile << "    }\n\n";
        outFile << "private:\n";
        outFile << "    std::unique_ptr<SCXML::SCXMLEngine> engine;\n";
        outFile << "};\n\n";

        // Generate usage example
        outFile << "// Usage example:\n";
        outFile << "// " << className << " sm;\n";
        outFile << "// sm.start();\n";
        outFile << "// sm.processEvent(\"user_input\");\n";

        outFile.close();

        LOG_INFO("Code generation completed successfully");
        SCE::LOG_INFO("Generated: {}", outputFile);

        return 0;

    } catch (const std::exception &e) {
        SCE::LOG_ERROR("Error: {}", e.what());
        return 1;
    }
}
